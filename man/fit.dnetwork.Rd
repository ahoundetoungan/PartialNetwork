% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit.dnetwork.R
\name{fit.dnetwork}
\alias{fit.dnetwork}
\title{Fitting Network Distribution}
\usage{
fit.dnetwork(
  object,
  traitARD,
  traitnonARD = NULL,
  m,
  burnin = NULL,
  print = TRUE
)
}
\arguments{
\item{object}{is an `estim.ARD` object returned by \code{\link{mcmcARD}}}

\item{traitARD}{is the matrix of traits for individuals with ARD. The entry (i, k) is 1 if i has the trait k and 0 otherwise.}

\item{traitnonARD}{is the matrix of traits for individuals without ARD. The entry (j, k) is 1 if j has the trait k and 0 otherwise.}

\item{m}{is the number of neighbors used to compute the gregariousness and the degree for individuals without ARD.}

\item{burnin}{is the number of simulations from the posterior distribution used as burn-in. The network distribution will be computed
used the simulation from the iteration \code{burnin + 1}.}

\item{print}{is logical; if TRUE, the progression will be printed in the console.}
}
\value{
a matrix of linking probabilities.
}
\description{
\code{fit.dnetwork} compute the network distribution from the simulations of the posterior distribution of the 
network formation model. The linking probabilities are also computed for individuals without ARD if their traits are observed.
The degree and the gregariousness of theses individuals are computed from the sample with ARD using m-nearest neighbors method.
}
\examples{
\dontrun{
set.seed(123)

# GENERATE DATA
# Sample size
N  <- 500 
n  <- 300

# ARD parameters
genzeta <- 1
mu      <- -1.35
sigma   <- 0.37
K       <- 12    # number of traits
P       <- 3     # Sphere dimension 

# Generate z (spherical coordinates)
genz    <- rvMF(N,rep(0,P))

# Genetate nu  from a Normal distribution with parameters mu and sigma (The gregariousness)
gennu   <- rnorm(N,mu,sigma)

# compute degrees
gend <- N*exp(gennu)*exp(mu+0.5*sigma^2)*exp(logCpvMF(P,0) - logCpvMF(P,genzeta))

# Link probabilities
Probabilities <- sim.dnetwork(gennu,gend,genzeta,genz) 

# Adjacency matrix
G <- sim.network(Probabilities)

# Generate vk, the trait location
genv <- rvMF(K,rep(0,P))

# set fixed some vk  distant
genv[1,] <- c(1,0,0)
genv[2,] <- c(0,1,0)
genv[3,] <- c(0,0,1)

# eta, the intensity parameter
geneta   <-abs(rnorm(K,2,1))

# Build traits matrix
densityatz      <- matrix(0,N,K)
for(k in 1:K){
  densityatz[,k] <- dvMF(genz,genv[k,]*geneta[k])
}

trait       <- matrix(0,N,K)
for(k in 1:K){
  trait[,k] <- densityatz[,k]>sort(densityatz[,k],decreasing = T)[runif(1,0.05*N,0.25*N)]
}

# print a percentage of peaople having a trait
colSums(trait)*100/N

# Build ADR
ARD         <- G \%*\% trait

# generate b
genb        <- numeric(K)
for(k in 1:K){
  genb[k]   <- sum(G[,trait[,k]==1])/sum(G)
}

############ ARD Posterior distribution ################### 
# EXAMPLE 1: ARD observed for the whole population
# initialization 
d0     <- exp(rnorm(N)); b0 <- exp(rnorm(K)); eta0 <- rep(1,K);
zeta0  <- 1; z0 <- matrix(rvMF(N,rep(0,P)),N); v0 <- matrix(rvMF(K,rep(0,P)),K)

# We should fix one bk
vfixcolumn      <- 1:5
bfixcolumn      <- c(3, 5)
b0[bfixcolumn]  <- genb[bfixcolumn]
v0[vfixcolumn,] <- genv[vfixcolumn,]

start  <- list("z" = z0, "v" = v0, "d" = d0, "b" = b0, "eta" = eta0, "zeta" = zeta0)
# MCMC ARD
out    <- mcmcARD(Y = ARD, traitARD = trait, start = start, fixv = vfixcolumn,
                  consb = bfixcolumn, iteration = 5000)
                  
# fit network distribution
dist   <- fit.dnetwork(out, traitARD = trait)

plot(rowSums(dist), gend)

# EXAMPLE 2: ARD observed for a sample from the population
# observed sample
traitard    <- trait[1:n, ]
traitnonard <- trait[(n + 1):N, ]
ARD         <- ARD[1:n,]

# initianalization 
d0     <- exp(rnorm(n)); b0 <- exp(rnorm(K)); eta0 <- rep(1,K);
zeta0  <- 1; z0 <- matrix(rvMF(n,rep(0,P)),n); v0 <- matrix(rvMF(K,rep(0,P)),K)

# We should fix one bk
vfixcolumn      <- 1:5
bfixcolumn      <- c(3, 5)
b0[bfixcolumn]  <- genb[bfixcolumn]
v0[vfixcolumn,] <- genv[vfixcolumn,]

start  <- list("z" = z0, "v" = v0, "d" = d0, "b" = b0, "eta" = eta0, "zeta" = zeta0)
# MCMC ARD
out    <- mcmcARD(Y = ARD, traitARD = traitard, start = start, fixv = vfixcolumn,
                  consb = bfixcolumn, iteration = 5000)
                  
# fit network distribution
dist   <- fit.dnetwork(out, traitARD = traitard, traitnonARD = traitnonard, m = 5)

plot(rowSums(dist)[1:n], gend[1:n], col = "blue")   # observed ard
points(rowSums(dist)[(n + 1):N], gend[(n + 1):N], col = "red")
}
}
