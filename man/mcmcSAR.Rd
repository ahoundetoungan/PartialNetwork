% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcmcSAR.R
\name{mcmcSAR}
\alias{mcmcSAR}
\title{Bayesian Estimator of SAR model}
\usage{
mcmcSAR(
  formula,
  contextual,
  start,
  G0.obs,
  G0 = NULL,
  mlinks = list(),
  hyperparms = list(),
  ctrl.mcmc = list(),
  iteration = 2000L,
  data
)
}
\arguments{
\item{formula}{object of class \link[stats]{formula}: a symbolic description of the model. The \code{formula} should be as for example \code{y ~ x1 + x2 | x1 + x2}
where \code{y} is the endogenous vector, the listed variables before the pipe, \code{x1}, \code{x2} are the individual exogenous variables and
the listed variables after the pipe, \code{x1}, \code{x2} are the contextual observable variables. Other formulas may be
\code{y ~ x1 + x2} for the model without contextual effects, \code{y ~ -1 + x1 + x2 | x1 + x2} for the model
without intercept or \code{ y ~ x1 + x2 | x2 + x3} to allow the contextual variable to be different from the individual variables.}

\item{contextual}{(optional) logical; if true, this means that all individual variables will be set as contextual variables. Set the
the \code{formula} as \code{y ~ x1 + x2} and \code{contextual} as \code{TRUE} is equivalent to set the formula as \code{y ~ x1 + x2 | x1 + x2}.}

\item{start}{(optional) vector of starting value of the model parameter as \eqn{(\beta' ~ \gamma' ~ \alpha ~ \sigma^2)'}{(\beta'  \gamma'  \alpha  se^2)'},
where \eqn{\beta} is the individual variables parameter, \eqn{\gamma} is the contextual variables parameter, \eqn{\alpha} is the peer effect parameter
and \eqn{\sigma^2}{se^2} the variance of the error term. If the \code{start} is missing, a Maximum Likelihood estimator will be used, where
the network matrix is that given through the argument \code{G0} (if provided) or generated from it distribution \code{dnetwork} (see argument \code{hyperparms}).}

\item{G0.obs}{list of matrices (or simply matrix if the list contains only one matrix) indicating the part of the network data which is observed. If the (i,j)-th element
of the m-th matrix is one, then the element at the same position in the network data will be considered as observed and will not be inferred in the MCMC. In contrast,
if the (i,j)-th element of the m-th matrix is zero, the element at the same position in the network data will be considered as a starting value of the missing link which will be inferred.
\code{G0.obs} can also take \code{none} when no part of the network data is observed (equivalent to the case where all the entries are zeros) and \code{all} when the network data is fully
observed (equivalent to the case where all the entries are ones).}

\item{G0}{list of sub-network matrices (or simply network matrix if there is only one sub-network). \code{G0} is made up of starting values for the entries with missing network data and observed values for the entries with
observed network data. \code{G0} is optional when \code{G0.obs = "none"}.}

\item{mlinks}{list specifying the network formation model (see details).}

\item{hyperparms}{(optional) is a list of hyperparameters (see details).}

\item{ctrl.mcmc}{list of MCMC controls (see details).}

\item{iteration}{number of MCMC steps to be performed.}

\item{data}{optional data frame, list or environment (or object coercible by \link[base]{as.data.frame} to a data frame) containing the variables
in the model. If not found in data, the variables are taken from \code{environment(formula)}, typically the environment from which \code{mcmcARD} is called.}
}
\value{
A list consisting of:
\item{n.group}{number of groups.}
\item{N}{vector of each group size.}
\item{time}{elapsed time to run the MCMC in second.}
\item{iteration}{number of MCMC steps performed.}
\item{posterior}{matrix (or list of matrices) containing the simulations.}
\item{hyperparms}{return value of \code{hyperparms}.}
\item{mlinks}{return value of \code{mlinks}.}
\item{accept.rate}{acceptance rates.}
\item{propG0.obs}{proportion of observed network data.}
\item{method.net}{network formation model specification.}
\item{start}{starting values.}
\item{formula}{input value of \code{formula}.}
\item{contextual}{input value of \code{contextual}.}
\item{ctrl.mcmc}{return value of \code{ctrl.mcmc}.}
}
\description{
\code{mcmcSAR} implements the Bayesian estimator of the linear-in-mean SAR model when only the linking probabilities are available or can be estimated.
}
\details{
\subsection{Outcome model}{

The model is given by
\deqn{\mathbf{y} = \mathbf{X}\beta + \mathbf{G}\mathbf{X}\gamma + \alpha \mathbf{G}\mathbf{y} + \epsilon.}{y = X\beta + GX\gamma + \alpha Gy + \epsilon,}
where \deqn{\epsilon ~ N(0, \sigma^2).}{\epsilon ~ N(0, se^2).}
The parameters to estimate in this model are the matrix \eqn{\mathbf{G}}{G}, the vectors \eqn{\beta}, \eqn{\gamma} and the scalar \eqn{\alpha}, \eqn{\sigma}{se}.
Prior distributions are assumed on \eqn{\mathbf{A}}, the adjacency matrix in which \eqn{\mathbf{A}_{ij} = 1}{A[i,j] = 1} if i is  connected to j and
\eqn{\mathbf{A}_{ij} = 0}{A[i,j] = 0} otherwise, and on \eqn{\beta}, \eqn{\gamma}, \eqn{\alpha} and \eqn{\sigma^2}{se^2}.
\deqn{\mathbf{A}_{ij} \sim Bernoulli(\mathbf{P}_{ij})}{A[i,j] ~ Bernoulli(P[i,j])}
\deqn{(\beta' ~ \gamma')'|\sigma^2 \sim \mathcal{N}(\mu_{\theta}, \sigma^2\Sigma_{\theta})}{(\beta' \gamma')'|se^2 ~ N(mutheta, se^2*stheta)}
\deqn{\zeta = \log\left(\frac{\alpha}{1 - \alpha}\right) \sim \mathcal{N}(\mu_{\zeta}, \sigma_{\zeta}^2)}{\zeta = log(\alpha/(1 - \alpha)) ~ N(muzeta, szeta)}
\deqn{\sigma^2 \sim IG(\frac{a}{2}, \frac{b}{2})}{se^2 ~ IG(a/2, b/2)}
where \eqn{\mathbf{P}}{P} is the linking probability. The linking probability is an hyperparameters that can be set fixed or updated using a network formation model.
}

\subsection{Network formation model}{

The linking probability can be set fixed or updated using a network formation model. Information about how \code{P} should be handled in in the MCMC can be set through the
argument \code{mlinks} which should be a list with named elements. Divers specifications of network formation model are possible. The list assigned to \code{mlist} should include
an element named \code{model}. The expected values of \code{model} are \code{"none"} (default value), \code{"logit"}, \code{"probit"}, and \code{"latent space"}.
\itemize{
\item \code{"none"} means that the network distribution \eqn{P} is set fixed throughout the MCMC,
\item \code{"probit"} and \code{"logit"} imply that the network distribution \eqn{P} will be updated using a Probit or Logit model,
\item \code{"latent spate"} means that \eqn{P} will be updated using Breza et al. (2020).}
\subsection{Fixed network distribution}{

To set \eqn{P} fixed, \code{mlinks} could contain,
\itemize{
\item \code{dnetwork}, a list, where the m-th element is the matrix of
link probability in the m-th sub-network.
\item \code{model = "none"} (optional as \code{"none"} is the default value).
}
}

\subsection{Probit and Logit models}{

For the Probit and Logit specification as network formation model, the following element could be declared in \code{mlinks}.
\itemize{
\item \code{model = "probit"} or \code{model = "logit"}.
\item \code{coraviates} as a matrix of dyadic observable characteristics (distance) which explain link formation. Even in the case many sub-networks,
\code{covariates} is still a matrix as polled version (row combination) of sub-matrix in each sub-network. \code{covariates} should verify \code{nrow(covariates) == sum(N^2 - N)},
where \code{N} is a vector of the number of individual in each sub-network. Indeed, the rows of \code{covariates} are the explanatory variables of
the entries \eqn{(1, 2)}; \eqn{(1, 3)}; \eqn{(1, 4)}; ...; \eqn{(2, 1)}; \eqn{(2, 3)}; \eqn{(2, 4)}; ... of the link probability of the first sub-network and
so on in all the sub-networks. Functions \code{\link{mat.to.vec}} and \code{\link{vec.to.mat}} can be used to convert a list of distance matrices to format compatible with
\code{covariates} (see examples below).
\item \code{estimates} (optional when a part of the network is observed) is a list containing \code{rho}, a vector of the estimates of the Probit or Logit
parameters, and \code{var.rho} the covariance matrix of the estimator. These estimates can be automatically computed when a part of the network data is available.
In addition, if \code{G0.obs = "none"}, \code{estimates} should also include \code{N}, a vector of the number of individual in each sub-network.
}
}

\subsection{Latent space models}{

The following element could be declared in \code{mlinks}.
\itemize{
\item \code{model = "latent space"}.
\item \code{estimates} a list of objects of class \code{mcmcARD} as returned by the function \verb{\link{mcmcARD}}, where the m-th element is Breza et al. (2020) estimator in
in the m-th sub-network.
\item \code{covariates} (required only when ARD are partially observed) is a list of matrices, where the m-th matrix contains the variables to use to compute distance between individuals (could be the list of traits).
The distances are used to compute gregariousness and coordinates for individuals without ARD by k-nearest approach.
\item \code{obsARD} (required only when ARD are partially observed) is a list of logical vectors, where the i-th entry of the m-th vector indicates by \code{TRUE} or \code{FALSE} if  the i-th individual in the m-th
sub-network has ARD or not.
\item \code{mARD} (optional, default value is \verb{rep(1, M})) is a vector, where the m-th entry is the number of neighbors to use in the m-th sub-network for the k-nearest approach.
\item \code{burninARD} (optional) set the burn-in to summarize the posterior distribution in \code{estimates}. The default valued use the last 50\% of simulations.
}
}

}

\subsection{Hyperparameters}{

All the hyperparameters can be defined through the argument \code{hyperparms} (a list) and should be named as follow.
\itemize{
\item \code{mutheta}, the prior mean of \eqn{(\beta' ~ \gamma')'|\sigma^2}{(\beta' ~ \gamma')'|se^2}. The default value assumes that
the prior mean is zero.
\item \code{invstheta} as \eqn{\Sigma_{\theta}^{-1}}{inverse of `stheta`}. The default value is a diagonal matrix with 0.01 on the diagonal.
\item \code{muzeta}, the prior mean of \eqn{\zeta}. The default value is zero.
\item \code{invszeta}, the inverse of the prior variance of \eqn{\zeta} with default value equal to 2.
\item \code{a} and \code{b} which default values equal to 4.2 and 2.2 respectively. This means for example that the prior mean of \eqn{\sigma^2}{se^2} is 1.
}
Inverses are used for the prior variance through the argument \code{hyperparms}  in order to allow non informative prior. Set the inverse of the prior
variance to 0 is equivalent to assume a non informative prior.
}

\subsection{Adaptive MCMC}{

During the MCMC, the jumping scales of \eqn{\alpha} and \eqn{\rho} are updated following AtchadÃ© and Rosenthal (2005) in order to target the acceptance rate to the \code{target} value. This
requires to set a minimal and a maximal jumping scales through the parameter \code{ctrl.mcmc}. The parameter \code{ctrl.mcmc} is a list which can contain the following named components.
\itemize{
\item{\code{target}}: the default value is \code{c("alpha" = 0.44, "rho" = 0.27)}.
\item{\code{jumpmin}}: the default value is \code{c("alpha" = 1e-12, "rho" = 1e-12)}.
\item{\code{jumpmax}}: the default value is \code{c("alpha" = 10, "rho" = 10)}.
\item{\code{print.level}}: an integer in \{0, 1, 2\} that indicates if the MCMC progression should be printed in the console.
If 0, the MCMC progression is not be printed. If 1 (default value), the progression is printed and if 2,
the simulations from the posterior distribution are printed.
\item{\code{block.max}}: The maximal number of entries that can be updated simultaneously in \eqn{\mathbf{A}}{A}. It might be
more efficient to update simultaneously 2 or 3 entries (see Boucher and Houndetoungan, 2020).
}
If \code{block.max} > 1, several entries are randomly chosen from the same row and updated simultaneously. The number of entries chosen is randomly
chosen between 1 and \code{block.max}. In addition, the entries are not chosen in order. For example, on the row i, the entries (i, 5) and (i, 9) can be updated simultaneously,
then the entries (i, 1), (i, 3), (i, 8), and so on.
}
}
\examples{
\donttest{
#################### EXAMPLE I: WITHOUT NETWORK FORMATION MODEL ####################
# Number of groups
M             <- 50
# size of each group
N             <- rep(30,M)
# individual effects
beta          <- c(2,1,1.5) 
# contextual effects
gamma         <- c(5,-3) 
# endogenous effects
alpha         <- 0.4
# std-dev errors
se            <- 1 
# prior distribution
prior         <- runif(sum(N*(N-1)))
prior         <- vec.to.mat(prior, N, normalise = FALSE)
# covariates
X             <- cbind(rnorm(sum(N),0,5),rpois(sum(N),7))
# true network
G0            <- sim.network(prior)
# normalise 
G0norm        <- norm.network(G0)
# simulate dependent variable use an external package
y             <- CDatanet::simSARnet(~ X, contextual = TRUE, Glist = G0norm, 
                                     theta = c(alpha, beta, gamma, se))
y             <- y$y
# dataset
dataset       <- as.data.frame(cbind(y, X1 = X[,1], X2 = X[,2])) 
############### Example I-1: When the network is fully observed ###############
out.none1     <- mcmcSAR(formula = y ~ X1 + X2, contextual = TRUE, G0.obs = "all",
                         G0 = G0, data = dataset, iteration = 1e4)
summary(out.none1)
plot(out.none1)
plot(out.none1, plot.type = "dens")

############### Example I-2: When a part of the network is observed ###############
# 60\% of the network data is observed
G0.obs       <- lapply(N, function(x) matrix(rbinom(x^2, 1, 0.6), x))
# replace the non-observed part of the network by 0 (missing links)
G0.start     <- lapply(1:M, function(x) G0[[x]]*G0.obs[[x]])
# Use network with missing data as the true network
out.none2.1  <- mcmcSAR(formula = y ~ X1 + X2, contextual = TRUE, G0.obs = "all",
                        G0 = G0.start,   data = dataset, iteration = 1e4)
summary(out.none2.1) # the peer effets seem overestimated
plot(out.none2.1)
plot(out.none2.1, plot.type = "dens")
# Infer the missing links in the network data
# In this example, the distribution of the network is set fixed
out.none2.2  <- mcmcSAR(formula = y ~ X1 + X2, contextual = TRUE, G0.obs = G0.obs,
                        G0 = G0.start,   data = dataset, mlinks = list(dnetwork = prior),
                        iteration = 2e4)
summary(out.none2.2)
plot(out.none2.2)
plot(out.none2.2, plot.type = "dens")

############### Example I-3: When only the network distribution is available ###############
# Simulate a fictitious network and use as true network
G0.tmp       <- sim.network(prior)
out.none3.1  <- mcmcSAR(formula = y ~ X1 + X2, contextual = TRUE, G0.obs = "all",
                        G0 = G0.tmp, data = dataset, iteration = 1e4)
summary(out.none3.1)  # the peer effets seem overestimated
plot(out.none3.1)
plot(out.none3.1, plot.type = "dens")
# Infer the network data
out.none3.2  <- mcmcSAR(formula = y ~ X1 + X2, contextual = TRUE, G0.obs = "none",
                        G0 = G0.tmp, data = dataset, mlinks = list(dnetwork = prior),
                        iteration = 2e4)
summary(out.none3.2)  
plot(out.none3.2)
plot(out.none3.2, plot.type = "dens")


#################### EXAMPLE II: NETWORK FORMATION MODEL: LOGIT ####################
# Number of groups
M             <- 50
# size of each group
N             <- rep(30,M)
# individual effects
beta          <- c(2,1,1.5) 
# contextual effects
gamma         <- c(5,-3) 
# endogenous effects
alpha         <- 0.4
# std-dev errors
se            <- 2 
# parameters of the network formation model
rho           <- c(-2, -.5, .2)
# covariates
X             <- cbind(rnorm(sum(N),0,5),rpois(sum(N),7))
# compute distance between individuals 
tmp           <- c(0, cumsum(N))
X1l           <- lapply(1:M, function(x) X[c(tmp[x] + 1):tmp[x+1],1])
X2l           <- lapply(1:M, function(x) X[c(tmp[x] + 1):tmp[x+1],2])
dist.net      <- function(x, y) abs(x - y) # distance function
X1.mat        <- lapply(1:M, function(m) {
                 matrix(kronecker(X1l[[m]], X1l[[m]], FUN = dist.net), N[m])}
                 )
X2.mat        <- lapply(1:M, function(m) {
                 matrix(kronecker(X2l[[m]], X2l[[m]], FUN = dist.net), N[m])}
                 )
# true network
covar         <- as.matrix(cbind("Const" = 1, 
                                 "dX1"   = mat.to.vec(X1.mat), 
                                 "dX2"   = mat.to.vec(X2.mat)))
ynet          <- covar \%*\% rho
ynet          <- 1*((ynet + rlogis(length(ynet))) > 0)
G0            <- vec.to.mat(ynet, N, normalise = FALSE)
G0norm        <- norm.network(G0)
# simulate dependent variable use an external package
y             <- CDatanet::simSARnet(~ X, contextual = TRUE, Glist = G0norm, 
                                     theta = c(alpha, beta, gamma, se))
y             <- y$y
# dataset
dataset       <- as.data.frame(cbind(y, X1 = X[,1], X2 = X[,2])) 
############### Example II-1: When the network is fully observed ###############
out.prob1     <- mcmcSAR(formula = y ~ X1 + X2, contextual = TRUE, G0.obs = "all",
                         G0 = G0norm, data = dataset, iteration = 1e4)
summary(out.prob1)
plot(out.prob1)
plot(out.prob1, plot.type = "dens")

############### Example II-2: When a part of the network is observed ###############
# 60\% of the network data is observed
G0.obs       <- lapply(N, function(x) matrix(rbinom(x^2, 1, 0.6), x))
# replace the non-observed part of the network by 0
G0.start     <- lapply(1:M, function(x) G0[[x]]*G0.obs[[x]])
# Use network with missing data as the true network
out.prob2.1  <- mcmcSAR(formula = y ~ X1 + X2, contextual = TRUE, G0.obs = "all",
                        G0 = G0.start,   data = dataset, iteration = 1e4)
summary(out.prob2.1) # the peer effets seem overestimated
plot(out.prob2.1)
plot(out.prob2.1, plot.type = "dens")
# Infer the missing links in the network data
out.prob2.2  <- mcmcSAR(formula = y ~ X1 + X2, contextual = TRUE, G0.obs = G0.obs,
                        G0 = G0.start,   data = dataset, 
                        mlinks = list(model = "logit", covariates = covar), iteration = 2e4)
summary(out.prob2.2)
plot(out.prob2.2)
plot(out.prob2.2, plot.type = "dens")
plot(out.prob2.2, which.parms = "rho")

############### Example II-3: When only the network distribution is available ###############
# Simulate a fictitious network and use as true network
G0.tmp       <- sim.network(vec.to.mat(plnorm(covar \%*\% rho), N))
out.prob3.1  <- mcmcSAR(formula = y ~ X1 + X2, contextual = TRUE, G0.obs = "all",
                        G0 = G0.tmp, data = dataset, iteration = 1e4)
summary(out.prob3.1)  # the peer effets seem overestimated
plot(out.prob3.1)
plot(out.prob3.1, plot.type = "dens")
# Infer the network data
# We provide information only about rho
Gvec         <- mat.to.vec(G0, ceiled = TRUE)
logestim     <- glm(Gvec ~ -1 + covar, family = binomial(link = "logit"))
slogestim    <- summary(logestim)
estimates    <- list("rho"     = logestim$coefficients, 
                     "var.rho" = slogestim$cov.unscaled,
                     "N"       = N)
out.prob3.2  <- mcmcSAR(formula = y ~ X1 + X2, contextual = TRUE, G0.obs = "none", data = dataset, 
                        mlinks = list(model = "logit", covariates = covar, estimates = estimates),
                        iteration = 2e4)
summary(out.prob3.2)  
plot(out.prob3.2)
plot(out.prob3.2, plot.type = "dens")
plot(out.prob3.2, which.parms = "rho")
}
}
\seealso{
\code{\link{sim.IV}}
}
