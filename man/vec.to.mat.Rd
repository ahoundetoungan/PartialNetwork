% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/convertMV.R, R/simNetwork.R
\name{vec.to.mat}
\alias{vec.to.mat}
\alias{mat.to.vec}
\alias{norm.network}
\title{Creating objects for network models}
\usage{
vec.to.mat(u, N, normalise = FALSE)

mat.to.vec(W, ceiled = FALSE)

norm.network(W)
}
\arguments{
\item{u}{numeric vector to convert.}

\item{N}{vector of sub-network sizes  such that \code{length(u) == sum(N*(N - 1))}.}

\item{normalise}{boolean takes \code{TRUE} if the returned matrices should be row-normalized and \code{FALSE} otherwise.}

\item{W}{matrix or list of matrixes to convert.}

\item{ceiled}{boolean takes \code{TRUE} if the given matrices should be ceiled before conversion and \code{FALSE} otherwise..}
}
\description{
\code{vec.to.mat} creates a list of square matrices from a given vector.
The elements of the generated matrices are taken from the vector and placed column-wise (ie. the first column is filled up before filling the second column) and from the first matrix of the list to the last matrix of the list.
The diagonal of the generated matrices are zeros.
\code{mat.to.vec} creates a vector from a given list of square matrices .
The elements of the generated vector are taken from column-wise and from the first matrix of the list to the last matrix of the list, while dropping the diagonal entry.
\code{norm.network} row-normalizes matrices in a given list.
}
\examples{
\donttest{
# Generate a list of adjacency matrices
## sub-network size
N <- c(250, 370, 120)  
## rate of friendship
p <- c(.2, .15, .18)   
## network data
u <- unlist(lapply(1: 3, function(x) rbinom(N[x]*(N[x] - 1), 1, p[x])))
W <- vec.to.mat(u, N)

# Convert G into a list of non-normalized matrices
G <- norm.network(W)

# recover u
v <- mat.to.vec(G, ceiled = TRUE)
all.equal(u, v)
}
}
\seealso{
\code{\link{sim.network}}, \code{\link{sim.dnetwork}}
}
